"""Generated item model for evaluation sessions.

This module defines the GeneratedItem value object that represents
an item generated by the LLM from a skill blueprint. It stores both
the question content and the correct answer for verification.

Generated items are stored as part of the Session aggregate's items list.
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Any
from uuid import uuid4

from domain.models.blueprint_models import DifficultyLevel, EvaluationMethod, ItemType


@dataclass
class GeneratedItem:
    """A generated assessment item with content and answer.

    This value object captures everything about a generated item:
    - The question content (stem, options)
    - The correct answer (stored securely, never sent to browser)
    - Generation metadata (skill, difficulty, timing)
    - User response data (filled after user responds)

    Attributes:
        id: Unique identifier for this item
        skill_id: Source skill blueprint ID
        domain_id: Exam domain this item belongs to
        sequence_number: Order in session (1-indexed)

        # Generation metadata
        generated_at: When the item was generated
        difficulty_level: Difficulty level used
        difficulty_value: Numeric difficulty (0.0-1.0)

        # Item content
        item_type: Type of item (multiple_choice, free_text, code)
        stem: The question text
        options: List of choices (for multiple choice)
        options_shuffled: Whether options were shuffled

        # Correct answer (NEVER sent to browser)
        correct_answer: The correct answer value
        correct_index: Index in options array (for multiple choice)
        explanation: Explanation of why answer is correct

        # Response data (filled after user responds)
        user_response: The user's submitted response
        user_response_index: Index selected (for multiple choice)
        is_correct: Whether response matches correct answer
        response_time_ms: Time from presentation to response
        responded_at: When user responded
    """

    # Identity
    id: str
    skill_id: str
    domain_id: str
    sequence_number: int

    # Generation metadata
    generated_at: datetime
    difficulty_level: DifficultyLevel
    difficulty_value: float

    # Item content
    item_type: ItemType
    stem: str
    options: list[str] = field(default_factory=list)
    options_shuffled: bool = False

    # Correct answer (NEVER sent to browser)
    correct_answer: str = ""
    correct_index: int | None = None
    explanation: str = ""
    evaluation_method: EvaluationMethod = EvaluationMethod.EXACT_MATCH

    # Response data
    user_response: str | None = None
    user_response_index: int | None = None
    is_correct: bool | None = None
    response_time_ms: float | None = None
    responded_at: datetime | None = None

    @classmethod
    def create(
        cls,
        skill_id: str,
        domain_id: str,
        sequence_number: int,
        difficulty_level: DifficultyLevel,
        difficulty_value: float,
        item_type: ItemType,
        stem: str,
        correct_answer: str,
        options: list[str] | None = None,
        correct_index: int | None = None,
        explanation: str = "",
        evaluation_method: EvaluationMethod = EvaluationMethod.EXACT_MATCH,
        options_shuffled: bool = False,
    ) -> "GeneratedItem":
        """Factory method to create a new generated item."""
        return cls(
            id=str(uuid4()),
            skill_id=skill_id,
            domain_id=domain_id,
            sequence_number=sequence_number,
            generated_at=datetime.now(UTC),
            difficulty_level=difficulty_level,
            difficulty_value=difficulty_value,
            item_type=item_type,
            stem=stem,
            options=options or [],
            options_shuffled=options_shuffled,
            correct_answer=correct_answer,
            correct_index=correct_index,
            explanation=explanation,
            evaluation_method=evaluation_method,
        )

    def record_response(
        self,
        user_response: str,
        user_response_index: int | None = None,
        response_time_ms: float | None = None,
    ) -> None:
        """Record the user's response and compute correctness.

        Args:
            user_response: The user's submitted answer
            user_response_index: Index selected (for multiple choice)
            response_time_ms: Time taken to respond
        """
        self.user_response = user_response
        self.user_response_index = user_response_index
        self.response_time_ms = response_time_ms
        self.responded_at = datetime.now(UTC)

        # Compute correctness based on evaluation method
        self.is_correct = self._evaluate_response(user_response)

    def _evaluate_response(self, user_response: str) -> bool:
        """Evaluate whether the user's response is correct.

        Args:
            user_response: The user's submitted answer

        Returns:
            True if correct, False otherwise
        """
        if self.evaluation_method == EvaluationMethod.EXACT_MATCH:
            return user_response == self.correct_answer

        elif self.evaluation_method == EvaluationMethod.CASE_INSENSITIVE:
            return user_response.lower().strip() == self.correct_answer.lower().strip()

        elif self.evaluation_method == EvaluationMethod.NUMERIC_TOLERANCE:
            try:
                user_num = float(user_response)
                correct_num = float(self.correct_answer)
                tolerance = 0.001  # Default tolerance
                return abs(user_num - correct_num) <= tolerance
            except ValueError:
                return False

        elif self.evaluation_method == EvaluationMethod.REGEX_MATCH:
            import re

            try:
                pattern = re.compile(self.correct_answer)
                return bool(pattern.match(user_response))
            except re.error:
                return user_response == self.correct_answer

        # Default to exact match
        return user_response == self.correct_answer

    def to_presentation_dict(self, include_answer: bool = False) -> dict[str, Any]:
        """Convert to dictionary for presentation to agent/user.

        Args:
            include_answer: If True, include correct answer (for LEARNING mode only)

        Returns:
            Dictionary with presentation data
        """
        result: dict[str, Any] = {
            "item_id": self.id,
            "item_number": self.sequence_number,
            "item_type": self.item_type.value,
            "stem": self.stem,
            "domain_id": self.domain_id,
        }

        if self.options:
            result["options"] = self.options

        if include_answer:
            result["correct_answer"] = self.correct_answer
            if self.correct_index is not None:
                result["correct_index"] = self.correct_index
            if self.explanation:
                result["explanation"] = self.explanation

        return result

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for persistence.

        This includes ALL data including the correct answer,
        since it's stored in the backend.
        """
        return {
            "id": self.id,
            "skill_id": self.skill_id,
            "domain_id": self.domain_id,
            "sequence_number": self.sequence_number,
            "generated_at": self.generated_at.isoformat(),
            "difficulty_level": self.difficulty_level.value,
            "difficulty_value": self.difficulty_value,
            "item_type": self.item_type.value,
            "stem": self.stem,
            "options": self.options,
            "options_shuffled": self.options_shuffled,
            "correct_answer": self.correct_answer,
            "correct_index": self.correct_index,
            "explanation": self.explanation,
            "evaluation_method": self.evaluation_method.value,
            "user_response": self.user_response,
            "user_response_index": self.user_response_index,
            "is_correct": self.is_correct,
            "response_time_ms": self.response_time_ms,
            "responded_at": self.responded_at.isoformat() if self.responded_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "GeneratedItem":
        """Create from dictionary."""
        # Parse enums
        difficulty_level = DifficultyLevel(data.get("difficulty_level", "medium"))
        item_type = ItemType(data.get("item_type", "multiple_choice"))
        evaluation_method = EvaluationMethod(data.get("evaluation_method", "exact_match"))

        # Parse timestamps
        generated_at = data.get("generated_at")
        if isinstance(generated_at, str):
            generated_at = datetime.fromisoformat(generated_at)
        elif generated_at is None:
            generated_at = datetime.now(UTC)

        responded_at = data.get("responded_at")
        if isinstance(responded_at, str):
            responded_at = datetime.fromisoformat(responded_at)

        return cls(
            id=data["id"],
            skill_id=data["skill_id"],
            domain_id=data["domain_id"],
            sequence_number=data["sequence_number"],
            generated_at=generated_at,
            difficulty_level=difficulty_level,
            difficulty_value=data.get("difficulty_value", 0.5),
            item_type=item_type,
            stem=data["stem"],
            options=data.get("options", []),
            options_shuffled=data.get("options_shuffled", False),
            correct_answer=data.get("correct_answer", ""),
            correct_index=data.get("correct_index"),
            explanation=data.get("explanation", ""),
            evaluation_method=evaluation_method,
            user_response=data.get("user_response"),
            user_response_index=data.get("user_response_index"),
            is_correct=data.get("is_correct"),
            response_time_ms=data.get("response_time_ms"),
            responded_at=responded_at,
        )


@dataclass
class ItemPlanEntry:
    """An entry in the session's item generation plan.

    This defines which skill/difficulty to use for generating
    each item in sequence.

    Attributes:
        skill_id: The skill blueprint to use
        domain_id: The exam domain this item belongs to
        difficulty_level: Target difficulty
        sequence_number: Position in session (1-indexed)
    """

    skill_id: str
    domain_id: str
    difficulty_level: DifficultyLevel
    sequence_number: int

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "skill_id": self.skill_id,
            "domain_id": self.domain_id,
            "difficulty_level": self.difficulty_level.value,
            "sequence_number": self.sequence_number,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "ItemPlanEntry":
        """Create from dictionary."""
        return cls(
            skill_id=data["skill_id"],
            domain_id=data["domain_id"],
            difficulty_level=DifficultyLevel(data.get("difficulty_level", "medium")),
            sequence_number=data["sequence_number"],
        )


@dataclass
class DomainResult:
    """Results for a single exam domain.

    Attributes:
        domain_id: The domain identifier
        domain_name: Display name
        items_attempted: Number of items attempted
        items_correct: Number of correct responses
        total_time_ms: Total time spent on domain items
    """

    domain_id: str
    domain_name: str
    items_attempted: int = 0
    items_correct: int = 0
    total_time_ms: float = 0.0

    @property
    def accuracy(self) -> float:
        """Calculate accuracy percentage."""
        if self.items_attempted == 0:
            return 0.0
        return (self.items_correct / self.items_attempted) * 100.0

    @property
    def avg_time_ms(self) -> float:
        """Calculate average time per item."""
        if self.items_attempted == 0:
            return 0.0
        return self.total_time_ms / self.items_attempted

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "domain_id": self.domain_id,
            "domain_name": self.domain_name,
            "items_attempted": self.items_attempted,
            "items_correct": self.items_correct,
            "total_time_ms": self.total_time_ms,
            "accuracy": self.accuracy,
            "avg_time_ms": self.avg_time_ms,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "DomainResult":
        """Create from dictionary."""
        return cls(
            domain_id=data["domain_id"],
            domain_name=data.get("domain_name", data["domain_id"]),
            items_attempted=data.get("items_attempted", 0),
            items_correct=data.get("items_correct", 0),
            total_time_ms=data.get("total_time_ms", 0.0),
        )


@dataclass
class EvaluationResults:
    """Final results for an evaluation session.

    Attributes:
        total_items: Total number of items
        items_completed: Number of items answered
        items_correct: Number of correct answers
        score_percent: Overall score percentage
        passed: Whether passing score was achieved
        time_elapsed_seconds: Total time taken
        domain_results: Results broken down by domain
    """

    total_items: int
    items_completed: int
    items_correct: int
    score_percent: float
    passed: bool
    time_elapsed_seconds: float
    domain_results: list[DomainResult] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "total_items": self.total_items,
            "items_completed": self.items_completed,
            "items_correct": self.items_correct,
            "score_percent": self.score_percent,
            "passed": self.passed,
            "time_elapsed_seconds": self.time_elapsed_seconds,
            "domain_results": [d.to_dict() for d in self.domain_results],
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "EvaluationResults":
        """Create from dictionary."""
        domain_results = [DomainResult.from_dict(d) for d in data.get("domain_results", [])]
        return cls(
            total_items=data["total_items"],
            items_completed=data["items_completed"],
            items_correct=data["items_correct"],
            score_percent=data["score_percent"],
            passed=data["passed"],
            time_elapsed_seconds=data["time_elapsed_seconds"],
            domain_results=domain_results,
        )
